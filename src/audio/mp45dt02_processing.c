/*******************************************************************************
* Copyright (c) 2017, Alan Barr
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* * Redistributions of source code must retain the above copyright notice, this
*   list of conditions and the following disclaimer.
*
* * Redistributions in binary form must reproduce the above copyright notice,
*   this list of conditions and the following disclaimer in the documentation
*   and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************/

#include <string.h>
#include "ch.h"
#include "hal.h"
//#include "autogen_fir_coeffs.h"
//#include "debug.h"
#include "mp45dt02_processing.h"
#include "..\leds.h"
#include "pdm_filter.h"

/******************************************************************************/
/* Hardware configuration */
/******************************************************************************/

/* ChibiOS I2S driver in use */
#define MP45DT02_I2S_DRIVER                 I2SD2

/* STM32F4 configuration for the I2S configuration register */
#define I2SCFG_MODE_MASTER_RECEIVE          (SPI_I2SCFGR_I2SCFG_0 | SPI_I2SCFGR_I2SCFG_1)
#define I2SCFG_STD_I2S                      (0)
#define I2SCFG_STD_LSB_JUSTIFIED            (SPI_I2SCFGR_I2SSTD_1)
#define I2SCFG_STD_MSB_JUSTIFIED            (SPI_I2SCFGR_I2SSTD_0)
#define I2SCFG_STD_PCM                      (SPI_I2SCFGR_I2SSTD_0 | SPI_I2SCFGR_I2SSTD_1)
#define I2SCFG_CKPOL_STEADY_LOW             (0)
#define I2SCFG_CKPOL_STEADY_HIGH            (SPI_I2SCFGR_CKPOL)
#define I2SCFG_DATAFORMAT_32B				(SPI_I2SCFGR_DATLEN_1)

/* STM32F4 configuration for I2S prescalar register */
// In our case we want an audio sampling frequency Fs = 32 KHz.
// We use 32 bits frame mode, it means 32 bits for left channel and 32 bits for right channel, thus 64 bits at each sampling event.
//
// I2S source clock is PLLI2SCLK = 32 MHz (see mcuconf.h):
// PLLI2SCLK = HSE/PLLM x PLLN/PLLR = 8/8 x 192/6 = 32 MHz.
//
// I2S divider is composed by I2SDIV (linear prescaler) and ODD (odd factor), divider = (I2SDIV x 2) + ODD.
// The values for the divider depends on the desired audio sampling frequency Fs (32 KHz), the frame mode (32 bits) and the number of channels (2):
// Fs = I2SCLK / [(32x2) x ((2 x I2SDIV) + ODD)]
// => (2 x I2SDIV) + ODD = I2SCLK / [(32x2) x Fs]
// => I2SDIV = ((I2SCLK / [(32x2) x Fs]) - ODD) / 2
// => ODD = (I2SCLK / [(32x2) x Fs]) - (2 x I2SDIV) = (I2SCLK / [(32x2) x Fs]) & 1
// Thus:
// ODD = (32 MHz / (64 x 32 KHz)) & 1 = 0
// I2SDIV = ((32 MHz / (64 x 32 KHz)) - 0) / 2 = 8
//
// I2S output clock check: 32 MHz / divider = 32 MHz / [(8 x 2) + 0] = 2 MHz.
//
// This means that the I2S will read data at 2 MHz, 1 MHz for each channel (interleaved).
// The input clock for the microphones of 1 MHz is generated by a timer that is placed between the I2S and the microphones and simply halves the input
// clock of 2 MHz coming from the I2S.
//
// I2S bitrate = number of bits per channel x number of channels x sampling audio frequency Fs
// I2S bitrate = 32 x 2 x 32 KHz = 2.048 Mbits/s => I2S output clock confirmed.
//
// The number of samples required to get 1 ms of data is:
// 2.048 Mbs / 32 bits = 64000 32bit_samples/sec, 32000 32bit_samples/sec for left channel and 32000 32bit_samples/sec for right channel.
// 0.001 x 64000 = 64 32bit_samples in 1 ms, 32 32bit_samples (128 bytes) for left and 32 32bit_samples (128 bytes) for right.
// This value is needed to set the number of samples to acquire for DMA and also for the PDM to PCM library that works with 1 ms of data.
#define MP45DT02_I2SDIV                     8
#define MP45DT02_I2SODD                     0
#define I2SPR_I2SODD_SHIFT                  8

/* Debugging - check for buffer overflows */
#define MEMORY_GUARD                        0xDEADBEEF

uint8_t Channel_Demux[128] = {
  0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
  0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
  0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
  0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
  0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
  0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
  0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
  0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
  0x08, 0x09, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x0b,
  0x08, 0x09, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x0b,
  0x0c, 0x0d, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0f,
  0x0c, 0x0d, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0f,
  0x08, 0x09, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x0b,
  0x08, 0x09, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x0b,
  0x0c, 0x0d, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0f,
  0x0c, 0x0d, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0f
};

static struct {
    uint32_t offset;
    uint32_t number;
    uint16_t buffer[MP45DT02_BUFFER_SIZE_2B];
    uint32_t guard;
} mp45dt02I2sData;

//static struct {
//    arm_fir_decimate_instance_f32 decimateInstance;
//    float32_t state[FIR_COEFFS_LEN + MP45DT02_EXPANDED_BUFFER_SIZE - 1];
//    uint32_t guard;
//} cmsisDsp;

uint16_t PDM_buffer[MP45DT02_BUFFER_SIZE_2B/2] = {0};
uint16_t PCM_buffer[MP45DT02_BUFFER_SIZE_2B/2] = {0};

static thread_t *pMp45dt02ProcessingThd;
static THD_WORKING_AREA(mp45dt02ProcessingThdWA, 1024);
static semaphore_t mp45dt02ProcessingSem;

static I2SConfig mp45dt02I2SConfig;

//static float32_t mp45dt02ExpandedBuffer[MP45DT02_EXPANDED_BUFFER_SIZE];
//static float32_t mp45dt02DecimatedBuffer[MP45DT02_DECIMATED_BUFFER_SIZE];

static mp45dt02Config initConfig;

PDMFilter_InitStruct PDM_filter[2];

static void PDMDecoder_Init(void) {
	uint8_t i = 0;

	// Enable CRC peripheral to unlock the PDM library.
	rccEnableAHB1(RCC_AHB1ENR_CRCEN, FALSE);

	for(i=0; i<2; i++) {
		// Filter LP and HP Init.
		PDM_filter[i].LP_HZ = I2S_AUDIOFREQ_32K/2;
		PDM_filter[i].HP_HZ = 10;
		PDM_filter[i].Fs = I2S_AUDIOFREQ_32K*2; // Multiplied by 2 because the library works in 16 bits, but the microphones are acquired in 32 bits mode.
		PDM_filter[i].Out_MicChannels = 2;
		PDM_filter[i].In_MicChannels = 2;
		PDM_Filter_Init((PDMFilter_InitStruct *)&PDM_filter[i]);
	}
}

/* 
 * outBuffer: Array of floats, where each element is derived from an input in
 *            inBuffer.
 *            It must be of length MP45DT02_EXPANDED_BUFFER_SIZE
 * inBuffer: Array of I2S data that is to be expanded to a more useful datatype
 *           by this function.
 *           It must be of length MP45DT02_I2S_SAMPLE_SIZE_2B
 */
//static void expand(float32_t *outBuffer,
//                   const uint16_t *inBuffer)
//{
//    uint32_t bitIndex = 0;
//    uint16_t modifiedCurrentWord = 0;
//
//    memset(outBuffer, 0, sizeof(MP45DT02_EXPANDED_BUFFER_SIZE));
//
//    /* Move each bit from each uint16_t word to an element of output array. */
//    for(bitIndex=0;
//        bitIndex < MP45DT02_I2S_SAMPLE_SIZE_BITS;
//        bitIndex++)
//    {
//        if (bitIndex % 16 == 0)
//        {
//            modifiedCurrentWord = inBuffer[bitIndex/MP45DT02_I2S_WORD_SIZE_BITS];
//        }
//
//        if (modifiedCurrentWord & 0x8000)
//        {
//            outBuffer[bitIndex] = INT16_MAX;
//        }
//        else
//        {
//            outBuffer[bitIndex] = INT16_MIN;
//        }
//
//        modifiedCurrentWord = modifiedCurrentWord << 1;
//    }
//}

static THD_FUNCTION(mp45dt02ProcessingThd, arg)
{
    (void)arg;

    chRegSetThreadName(__FUNCTION__);

	uint32_t index = 0;
	uint16_t * DataTempI2S = &mp45dt02I2sData.buffer[mp45dt02I2sData.offset]; // Point to the last filled data, the other half of the buffer is being filled by DMA.
	//uint16_t * DataTempSPI = &(SPI_InternalBuffer[INTERNAL_BUFF_SIZE/2]);
	uint8_t a,b=0;

    while (chThdShouldTerminateX() == false)
    {
        chSemWait(&mp45dt02ProcessingSem);
        
        set_led(1, 2);

        if (chThdShouldTerminateX() == true)
        {
            break;
        }

        // We have MP45DT02_SAMPLE_SIZE_4B = 64 samples of 32 bits each (=> mp45dt02I2sData.number = 64).
        // Each sample is 32 bits, thus  64 * 32 bits = 2048 PDM samples.
        // The samples are interleaved left and right, this means that the first bit is left, the second is right, ...
        // Extract the bits sequence and transform it in order to have 1 byte left, 1 byte right, ...
        // This is needed by the library functions that convert PDM in PCM samples.
        for(index=0; index < mp45dt02I2sData.number*2; index++) { // We take in consideration 16 bits at a time, thus we loop twice as the number of samples.
			a = ((uint8_t *)(DataTempI2S))[(index*2)]; // MSByte.
			b = ((uint8_t *)(DataTempI2S))[(index*2)+1]; // LSByte.
			((uint8_t *)PDM_buffer)[(index*2)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] | Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4; // Extract left and swap bytes.
			((uint8_t *)PDM_buffer)[(index*2)+1] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4; // Extract right and swap bytes.
		}

        for(index = 0; index < MP45DT02_NUM_CHANNELS_PER_IF; index++) {
        	/* PDM to PCM filter */
        	PDM_Filter_64_LSB(&((uint8_t*)(PDM_buffer))[index], (uint16_t*)&(PCM_buffer[index]), AUDIO_IN_VOLUME , (PDMFilter_InitStruct *)&PDM_filter[index]);
        }

        if (mp45dt02I2sData.number != MP45DT02_SAMPLE_SIZE_4B*2)
        {
//            PRINT_CRITICAL("Unexpected number of samples provided. %d not %d.",
//                           mp45dt02I2sData.number,
//                           MP45DT02_I2S_SAMPLE_SIZE_2B);
        }

        /**********************************************************************/ 
        /* Convert I2S data to a useful format                                */
        /**********************************************************************/ 

//        expand(mp45dt02ExpandedBuffer,
//               &mp45dt02I2sData.buffer[mp45dt02I2sData.offset]);

        /**********************************************************************/ 
        /* Filtering                                                          */
        /**********************************************************************/ 

//        arm_fir_decimate_f32(&cmsisDsp.decimateInstance,
//                             mp45dt02ExpandedBuffer,
//                             mp45dt02DecimatedBuffer,
//                             MP45DT02_EXPANDED_BUFFER_SIZE);

        /**********************************************************************/ 
        /* Notify of new data                                                 */
        /**********************************************************************/ 

//        initConfig.fullbufferCb(mp45dt02DecimatedBuffer,
//                                MP45DT02_DECIMATED_BUFFER_SIZE);

        if (mp45dt02I2sData.guard != MEMORY_GUARD)
        {
//            PRINT_CRITICAL("Overflow detected.",0);
        }
//        if (cmsisDsp.guard != MEMORY_GUARD)
//        {
//            PRINT_CRITICAL("Overflow detected.",0);
//        }
    }
}

/* (*i2scallback_t) */
static void mp45dt02Cb(I2SDriver *i2sp, size_t offset, size_t number)
{
    (void)i2sp;
    set_led(0, 2);
    chSysLockFromISR();
    mp45dt02I2sData.offset = offset;
    mp45dt02I2sData.number = number;
    chSemSignalI(&mp45dt02ProcessingSem);
    chSysUnlockFromISR();
}

static void dspInit(void)
{
//    arm_status armStatus;
//
//    memset(&cmsisDsp, 0, sizeof(cmsisDsp));
//    cmsisDsp.guard = MEMORY_GUARD;
//
//    if (ARM_MATH_SUCCESS != (armStatus = arm_fir_decimate_init_f32(
//                                            &cmsisDsp.decimateInstance,
//                                            FIR_COEFFS_LEN,
//                                            MP45DT02_FIR_DECIMATION_FACTOR,
//                                            firCoeffs,
//                                            cmsisDsp.state,
//                                            MP45DT02_EXPANDED_BUFFER_SIZE)))
//    {
//        PRINT_CRITICAL("arm_fir_decimate_init_f32 failed with %d", armStatus);
//    }
}

void mp45dt02Init(mp45dt02Config *config)
{

    initConfig = *config;

    chSemObjectInit(&mp45dt02ProcessingSem, 0);

    pMp45dt02ProcessingThd = chThdCreateStatic(mp45dt02ProcessingThdWA,
                                               sizeof(mp45dt02ProcessingThdWA),
                                               NORMALPRIO+1,
                                               mp45dt02ProcessingThd, NULL);

    dspInit();

    PDMDecoder_Init();

    memset(&mp45dt02I2sData, 0, sizeof(mp45dt02I2sData));
    mp45dt02I2sData.guard = MEMORY_GUARD;

    memset(&mp45dt02I2SConfig, 0, sizeof(mp45dt02I2SConfig));
    mp45dt02I2SConfig.tx_buffer = NULL;
    mp45dt02I2SConfig.rx_buffer = mp45dt02I2sData.buffer;
    mp45dt02I2SConfig.size      = MP45DT02_SAMPLE_SIZE_4B*2; // 2 ms of data
    mp45dt02I2SConfig.end_cb    = mp45dt02Cb; // Callback function called at half-fill (1 ms of data) and full-fill (1 ms of data).

    mp45dt02I2SConfig.i2scfgr   = I2SCFG_MODE_MASTER_RECEIVE    |
                                  I2SCFG_STD_LSB_JUSTIFIED      |
                                  I2SCFG_CKPOL_STEADY_HIGH		|
								  I2SCFG_DATAFORMAT_32B;

    mp45dt02I2SConfig.i2spr     = (SPI_I2SPR_I2SDIV & MP45DT02_I2SDIV) |
                                  (SPI_I2SPR_ODD & (MP45DT02_I2SODD << I2SPR_I2SODD_SHIFT));

    i2sStart(&MP45DT02_I2S_DRIVER, &mp45dt02I2SConfig);
    i2sStartExchange(&MP45DT02_I2S_DRIVER);
}

void mp45dt02Shutdown(void)
{
    i2sStopExchange(&MP45DT02_I2S_DRIVER);
    i2sStop(&MP45DT02_I2S_DRIVER);

    chThdTerminate(pMp45dt02ProcessingThd);
    chSemReset(&mp45dt02ProcessingSem, 1);
    chThdWait(pMp45dt02ProcessingThd);
    pMp45dt02ProcessingThd = NULL;
}

