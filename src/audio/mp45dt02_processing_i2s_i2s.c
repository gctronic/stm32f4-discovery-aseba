/*******************************************************************************
* Copyright (c) 2017, Alan Barr
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* * Redistributions of source code must retain the above copyright notice, this
*   list of conditions and the following disclaimer.
*
* * Redistributions in binary form must reproduce the above copyright notice,
*   this list of conditions and the following disclaimer in the documentation
*   and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************/

#include <string.h>
#include "ch.h"
#include "hal.h"
//#include "autogen_fir_coeffs.h"
//#include "debug.h"
#include "mp45dt02_processing.h"
#include "..\leds.h"
#include "pdm_filter.h"

/******************************************************************************/
/* Hardware configuration */
/******************************************************************************/

/* ChibiOS I2S driver in use */
#define MP45DT02_I2S2_DRIVER                 I2SD2
#define MP45DT02_I2S3_DRIVER                 I2SD3

/* STM32F4 configuration for the I2S configuration register */
#define I2SCFG_MODE_MASTER_RECEIVE          (SPI_I2SCFGR_I2SCFG_0 | SPI_I2SCFGR_I2SCFG_1)
#define I2SCFG_STD_I2S                      (0)
#define I2SCFG_STD_LSB_JUSTIFIED            (SPI_I2SCFGR_I2SSTD_1)
#define I2SCFG_STD_MSB_JUSTIFIED            (SPI_I2SCFGR_I2SSTD_0)
#define I2SCFG_STD_PCM                      (SPI_I2SCFGR_I2SSTD_0 | SPI_I2SCFGR_I2SSTD_1)
#define I2SCFG_CKPOL_STEADY_LOW             (0)
#define I2SCFG_CKPOL_STEADY_HIGH            (SPI_I2SCFGR_CKPOL)
#define I2SCFG_DATAFORMAT_32B				(SPI_I2SCFGR_DATLEN_1)
#define I2SCFG_MODE_SLAVE_RECEIVE			(SPI_I2SCFGR_I2SCFG_0)

/* STM32F4 configuration for I2S prescalar register */
// In our case we want an audio sampling frequency Fs = 16 KHz.
// We use 32 bits frame mode, it means 32 bits for left channel and 32 bits for right channel, thus 64 bits at each sampling event.
// For the conversion from PDM to PCM we use a decimation factor = 64.
//
// Required I2S clock = Fs x decimation factor x number of channels
// Required I2S clock = 16 KHz x 64 x 2 = 2.048 MHz
//
// This means that the I2S will read data at 2 MHz, 1 MHz for each channel (interleaved).
// The input clock for the microphones of 1 MHz is generated by a timer that is placed between the I2S and the microphones and simply halves the input
// clock of 2 MHz coming from the I2S.
//
// I2S source clock is PLLI2SCLK = 32 MHz (see mcuconf.h):
// PLLI2SCLK = HSE/PLLM x PLLN/PLLR = 8/8 x 192/6 = 32 MHz.
//
// I2S divider is composed by I2SDIV (linear prescaler) and ODD (odd factor), divider = (I2SDIV x 2) + ODD.
// I2S clock = PLLI2SCLK / divider => divider = PLLI2SCLK / I2S clock
// => ODD =  (PLLI2SCLK / I2S clock) & 1 = (32 MHz / 2 MHz) & 1 = 0
// => I2SDIV = ((PLLI2SCLK / I2S clock) - ODD) / 2 = 8
//
// The number of samples required to get 1 ms of data is:
// 2.048 Mbs / 32 bits = 64000 32bit_samples/sec, 32000 32bit_samples/sec for left channel and 32000 32bit_samples/sec for right channel.
// 0.001 x 64000 = 64 32bit_samples in 1 ms, 32 32bit_samples (128 bytes) for left and 32 32bit_samples (128 bytes) for right.
// This value is needed to set the number of samples to acquire for DMA, since the PDM to PCM library works with 1 ms of data.
#define MP45DT02_I2SDIV                     8
#define MP45DT02_I2SODD                     0
#define I2SPR_I2SODD_SHIFT                  8

/* Debugging - check for buffer overflows */
#define MEMORY_GUARD                        0xDEADBEEF

uint8_t Channel_Demux[128] = {
  0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
  0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
  0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
  0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
  0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
  0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
  0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
  0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
  0x08, 0x09, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x0b,
  0x08, 0x09, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x0b,
  0x0c, 0x0d, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0f,
  0x0c, 0x0d, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0f,
  0x08, 0x09, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x0b,
  0x08, 0x09, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x0b,
  0x0c, 0x0d, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0f,
  0x0c, 0x0d, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0f
};

static struct {
    uint32_t offset;
    uint32_t number;
    uint16_t buffer[MP45DT02_BUFFER_SIZE_2B];
    uint32_t guard;
} mp45dt02I2s2Data, mp45dt02I2s3Data;

//static struct {
//    arm_fir_decimate_instance_f32 decimateInstance;
//    float32_t state[FIR_COEFFS_LEN + MP45DT02_EXPANDED_BUFFER_SIZE - 1];
//    uint32_t guard;
//} cmsisDsp;

uint16_t PDM_buffer_I2S2[MP45DT02_BUFFER_SIZE_2B/2] = {0};
uint16_t PCM_buffer_I2S2[MP45DT02_DECIMATED_BUFFER_SIZE] = {0};
uint16_t PCM_buffer_long_I2S2[MP45DT02_DECIMATED_BUFFER_SIZE*10] = {0};
uint8_t pcm_index_I2S2 = 0;

uint16_t PDM_buffer_I2S3[MP45DT02_BUFFER_SIZE_2B/2] = {0};
uint16_t PCM_buffer_I2S3[MP45DT02_DECIMATED_BUFFER_SIZE] = {0};
uint16_t PCM_buffer_long_I2S3[MP45DT02_DECIMATED_BUFFER_SIZE*10] = {0};
uint8_t pcm_index_I2S3 = 0;

static thread_t *I2S2ProcessingThd;
static THD_WORKING_AREA(I2S2ProcessingThdWA, 1024);
static semaphore_t I2S2ProcessingSem;

static thread_t *I2S3ProcessingThd;
static THD_WORKING_AREA(I2S3ProcessingThdWA, 1024);
static semaphore_t I2S3ProcessingSem;

static I2SConfig mp45dt02I2S2Config;
static I2SConfig mp45dt02I2S3Config;

//static float32_t mp45dt02ExpandedBuffer[MP45DT02_EXPANDED_BUFFER_SIZE];
//static float32_t mp45dt02DecimatedBuffer[MP45DT02_DECIMATED_BUFFER_SIZE];

static mp45dt02Config initConfig;

PDMFilter_InitStruct PDM_filter_I2S2[MP45DT02_NUM_CHANNELS];
PDMFilter_InitStruct PDM_filter_I2S3[MP45DT02_NUM_CHANNELS];

static void PDMDecoder_Init(void) {
	uint8_t i = 0;

	// Enable CRC peripheral to unlock the PDM library.
	rccEnableAHB1(RCC_AHB1ENR_CRCEN, FALSE);

	for(i=0; i<MP45DT02_NUM_CHANNELS; i++) {
		// Filter LP and HP Init.
		PDM_filter_I2S2[i].LP_HZ = I2S_AUDIOFREQ_16K/2;
		PDM_filter_I2S2[i].HP_HZ = 10;
		PDM_filter_I2S2[i].Fs = I2S_AUDIOFREQ_16K;
		PDM_filter_I2S2[i].Out_MicChannels = 2;
		PDM_filter_I2S2[i].In_MicChannels = 2;
		PDM_Filter_Init((PDMFilter_InitStruct *)&PDM_filter_I2S2[i]);

		PDM_filter_I2S3[i].LP_HZ = I2S_AUDIOFREQ_16K/2;
		PDM_filter_I2S3[i].HP_HZ = 10;
		PDM_filter_I2S3[i].Fs = I2S_AUDIOFREQ_16K;
		PDM_filter_I2S3[i].Out_MicChannels = 2;
		PDM_filter_I2S3[i].In_MicChannels = 2;
		PDM_Filter_Init((PDMFilter_InitStruct *)&PDM_filter_I2S3[i]);
	}

}

/* 
 * outBuffer: Array of floats, where each element is derived from an input in
 *            inBuffer.
 *            It must be of length MP45DT02_EXPANDED_BUFFER_SIZE
 * inBuffer: Array of I2S data that is to be expanded to a more useful datatype
 *           by this function.
 *           It must be of length MP45DT02_I2S_SAMPLE_SIZE_2B
 */
//static void expand(float32_t *outBuffer,
//                   const uint16_t *inBuffer)
//{
//    uint32_t bitIndex = 0;
//    uint16_t modifiedCurrentWord = 0;
//
//    memset(outBuffer, 0, sizeof(MP45DT02_EXPANDED_BUFFER_SIZE));
//
//    /* Move each bit from each uint16_t word to an element of output array. */
//    for(bitIndex=0;
//        bitIndex < MP45DT02_I2S_SAMPLE_SIZE_BITS;
//        bitIndex++)
//    {
//        if (bitIndex % 16 == 0)
//        {
//            modifiedCurrentWord = inBuffer[bitIndex/MP45DT02_I2S_WORD_SIZE_BITS];
//        }
//
//        if (modifiedCurrentWord & 0x8000)
//        {
//            outBuffer[bitIndex] = INT16_MAX;
//        }
//        else
//        {
//            outBuffer[bitIndex] = INT16_MIN;
//        }
//
//        modifiedCurrentWord = modifiedCurrentWord << 1;
//    }
//}

static THD_FUNCTION(I2S2Processing, arg)
{
    (void)arg;

    chRegSetThreadName(__FUNCTION__);

	uint32_t index = 0;
	uint16_t * DataTempI2S = &mp45dt02I2s2Data.buffer[mp45dt02I2s2Data.offset]; // Point to the last filled data, the other half of the buffer is being filled by DMA.
	uint8_t a,b=0;

    while (chThdShouldTerminateX() == false)
    {
        chSemWait(&I2S2ProcessingSem);
        
        //set_led(1, 2);

        if (chThdShouldTerminateX() == true)
        {
            break;
        }

        set_led(2, 1);
        // We have MP45DT02_SAMPLE_SIZE_4B = 64 samples of 32 bits each (=> mp45dt02I2sData.number = 64).
        // Each sample is 32 bits, thus  64 * 32 bits = 2048 PDM samples.
        // The samples are interleaved left and right, this means that the first bit is left, the second is right, ...
        // Extract the bits sequence and transform it in order to have 1 byte left, 1 byte right, ...
        // This is needed by the library functions that convert PDM in PCM samples.
        for(index=0; index < mp45dt02I2s2Data.number*2; index++) { // We take in consideration 16 bits at a time, thus we loop twice as the number of samples.
			a = ((uint8_t *)(DataTempI2S))[(index*2)]; // MSByte.
			b = ((uint8_t *)(DataTempI2S))[(index*2)+1]; // LSByte.
			((uint8_t *)PDM_buffer_I2S2)[(index*2)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] | Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4; // Extract left and swap bytes.
			((uint8_t *)PDM_buffer_I2S2)[(index*2)+1] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4; // Extract right and swap bytes.
		}

        set_led(3, 1);
        // Using a decimator factor of 64, we get 2048/64 = 32 PCM samples of 16 bits, 16 PCM for left channel and 16 PCM for right channel.
        for(index = 0; index < MP45DT02_NUM_CHANNELS; index++) {
        	/* PDM to PCM filter */
        	PDM_Filter_64_LSB(&((uint8_t*)(PDM_buffer_I2S2))[index], (uint16_t*)&(PCM_buffer_I2S2[index]), AUDIO_IN_VOLUME , (PDMFilter_InitStruct *)&PDM_filter_I2S2[index]);
        //	a+=(b*index);
        }
        set_led(3, 0);

        memcpy(&PCM_buffer_long_I2S2[pcm_index_I2S2*MP45DT02_DECIMATED_BUFFER_SIZE], &PCM_buffer_I2S2[0], MP45DT02_DECIMATED_BUFFER_SIZE*2);
        if(pcm_index_I2S2 == 9) {
        	pcm_index_I2S2 = 0;
        } else {
        	pcm_index_I2S2++;
        }

        set_led(2, 0);

        if (mp45dt02I2s2Data.number != MP45DT02_SAMPLE_SIZE_4B*2)
        {
//            PRINT_CRITICAL("Unexpected number of samples provided. %d not %d.",
//                           mp45dt02I2sData.number,
//                           MP45DT02_I2S_SAMPLE_SIZE_2B);
        }

        /**********************************************************************/ 
        /* Convert I2S data to a useful format                                */
        /**********************************************************************/ 

//        expand(mp45dt02ExpandedBuffer,
//               &mp45dt02I2sData.buffer[mp45dt02I2sData.offset]);

        /**********************************************************************/ 
        /* Filtering                                                          */
        /**********************************************************************/ 

//        arm_fir_decimate_f32(&cmsisDsp.decimateInstance,
//                             mp45dt02ExpandedBuffer,
//                             mp45dt02DecimatedBuffer,
//                             MP45DT02_EXPANDED_BUFFER_SIZE);

        /**********************************************************************/ 
        /* Notify of new data                                                 */
        /**********************************************************************/ 

//        initConfig.fullbufferCb(mp45dt02DecimatedBuffer,
//                                MP45DT02_DECIMATED_BUFFER_SIZE);

        if (mp45dt02I2s2Data.guard != MEMORY_GUARD)
        {
//            PRINT_CRITICAL("Overflow detected.",0);
        }
//        if (cmsisDsp.guard != MEMORY_GUARD)
//        {
//            PRINT_CRITICAL("Overflow detected.",0);
//        }
    }
}

static THD_FUNCTION(I2S3Processing, arg)
{
    (void)arg;

    chRegSetThreadName(__FUNCTION__);

	uint32_t index = 0;
	uint16_t * DataTempI2S = &mp45dt02I2s3Data.buffer[mp45dt02I2s3Data.offset]; // Point to the last filled data, the other half of the buffer is being filled by DMA.
	uint8_t a,b=0;

    while (chThdShouldTerminateX() == false)
    {
        chSemWait(&I2S3ProcessingSem);

        //set_led(1, 2);

        if (chThdShouldTerminateX() == true)
        {
            break;
        }

        set_led(2, 1);
        // We have MP45DT02_SAMPLE_SIZE_4B = 64 samples of 32 bits each (=> mp45dt02I2sData.number = 64).
        // Each sample is 32 bits, thus  64 * 32 bits = 2048 PDM samples.
        // The samples are interleaved left and right, this means that the first bit is left, the second is right, ...
        // Extract the bits sequence and transform it in order to have 1 byte left, 1 byte right, ...
        // This is needed by the library functions that convert PDM in PCM samples.
        for(index=0; index < mp45dt02I2s3Data.number*2; index++) { // We take in consideration 16 bits at a time, thus we loop twice as the number of samples.
			a = ((uint8_t *)(DataTempI2S))[(index*2)]; // MSByte.
			b = ((uint8_t *)(DataTempI2S))[(index*2)+1]; // LSByte.
			((uint8_t *)PDM_buffer_I2S3)[(index*2)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] | Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4; // Extract left and swap bytes.
			((uint8_t *)PDM_buffer_I2S3)[(index*2)+1] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4; // Extract right and swap bytes.
		}

        set_led(3, 1);
        // Using a decimator factor of 64, we get 2048/64 = 32 PCM samples of 16 bits, 16 PCM for left channel and 16 PCM for right channel.
        for(index = 0; index < MP45DT02_NUM_CHANNELS; index++) {
        	/* PDM to PCM filter */
        	PDM_Filter_64_LSB(&((uint8_t*)(PDM_buffer_I2S3))[index], (uint16_t*)&(PCM_buffer_I2S3[index]), AUDIO_IN_VOLUME , (PDMFilter_InitStruct *)&PDM_filter_I2S3[index]);
        //	a+=(b*index);
        }
        set_led(3, 0);

        memcpy(&PCM_buffer_long_I2S3[pcm_index_I2S3*MP45DT02_DECIMATED_BUFFER_SIZE], &PCM_buffer_I2S3[0], MP45DT02_DECIMATED_BUFFER_SIZE*2);
        if(pcm_index_I2S3 == 9) {
        	pcm_index_I2S3 = 0;
        } else {
        	pcm_index_I2S3++;
        }

        set_led(2, 0);

        if (mp45dt02I2s3Data.number != MP45DT02_SAMPLE_SIZE_4B*2)
        {
//            PRINT_CRITICAL("Unexpected number of samples provided. %d not %d.",
//                           mp45dt02I2sData.number,
//                           MP45DT02_I2S_SAMPLE_SIZE_2B);
        }

        /**********************************************************************/
        /* Convert I2S data to a useful format                                */
        /**********************************************************************/

//        expand(mp45dt02ExpandedBuffer,
//               &mp45dt02I2sData.buffer[mp45dt02I2sData.offset]);

        /**********************************************************************/
        /* Filtering                                                          */
        /**********************************************************************/

//        arm_fir_decimate_f32(&cmsisDsp.decimateInstance,
//                             mp45dt02ExpandedBuffer,
//                             mp45dt02DecimatedBuffer,
//                             MP45DT02_EXPANDED_BUFFER_SIZE);

        /**********************************************************************/
        /* Notify of new data                                                 */
        /**********************************************************************/

//        initConfig.fullbufferCb(mp45dt02DecimatedBuffer,
//                                MP45DT02_DECIMATED_BUFFER_SIZE);

        if (mp45dt02I2s3Data.guard != MEMORY_GUARD)
        {
//            PRINT_CRITICAL("Overflow detected.",0);
        }
//        if (cmsisDsp.guard != MEMORY_GUARD)
//        {
//            PRINT_CRITICAL("Overflow detected.",0);
//        }
    }
}

/* (*i2scallback_t) */
static void mp45dt02I2S2Cb(I2SDriver *i2sp, size_t offset, size_t number)
{
    (void)i2sp;
    set_led(0, 2);
    chSysLockFromISR();
    mp45dt02I2s2Data.offset = offset;
    mp45dt02I2s2Data.number = number;
    chSemSignalI(&I2S2ProcessingSem);
    chSysUnlockFromISR();
}

static void mp45dt02I2S3Cb(I2SDriver *i2sp, size_t offset, size_t number)
{
    (void)i2sp;
    set_led(1, 2);
    chSysLockFromISR();
    mp45dt02I2s3Data.offset = offset;
    mp45dt02I2s3Data.number = number;
    chSemSignalI(&I2S3ProcessingSem);
    chSysUnlockFromISR();
}

static void dspInit(void)
{
//    arm_status armStatus;
//
//    memset(&cmsisDsp, 0, sizeof(cmsisDsp));
//    cmsisDsp.guard = MEMORY_GUARD;
//
//    if (ARM_MATH_SUCCESS != (armStatus = arm_fir_decimate_init_f32(
//                                            &cmsisDsp.decimateInstance,
//                                            FIR_COEFFS_LEN,
//                                            MP45DT02_FIR_DECIMATION_FACTOR,
//                                            firCoeffs,
//                                            cmsisDsp.state,
//                                            MP45DT02_EXPANDED_BUFFER_SIZE)))
//    {
//        PRINT_CRITICAL("arm_fir_decimate_init_f32 failed with %d", armStatus);
//    }
}

void mp45dt02Init(mp45dt02Config *config)
{

    initConfig = *config;

    chSemObjectInit(&I2S2ProcessingSem, 0);

    I2S2ProcessingThd = chThdCreateStatic(I2S2ProcessingThdWA,
    									sizeof(I2S2ProcessingThdWA),
										NORMALPRIO+2,
										I2S2Processing, NULL);

    chSemObjectInit(&I2S3ProcessingSem, 0);

    I2S3ProcessingThd = chThdCreateStatic(I2S3ProcessingThdWA,
    									sizeof(I2S3ProcessingThdWA),
										NORMALPRIO+1,
										I2S3Processing, NULL);

    dspInit();

    PDMDecoder_Init();

    //*******************
    // I2S2 configuration
    //*******************
    memset(&mp45dt02I2s2Data, 0, sizeof(mp45dt02I2s2Data));
    mp45dt02I2s2Data.guard = MEMORY_GUARD;

    memset(&mp45dt02I2S2Config, 0, sizeof(mp45dt02I2S2Config));
    mp45dt02I2S2Config.tx_buffer = NULL;
    mp45dt02I2S2Config.rx_buffer = mp45dt02I2s2Data.buffer;
    mp45dt02I2S2Config.size      = MP45DT02_SAMPLE_SIZE_4B*2; // 2 ms of data
    mp45dt02I2S2Config.end_cb    = mp45dt02I2S2Cb; // Callback function called at half-fill (1 ms of data) and full-fill (1 ms of data).

    mp45dt02I2S2Config.i2scfgr   = I2SCFG_MODE_MASTER_RECEIVE    |
                                  I2SCFG_STD_LSB_JUSTIFIED      |
                                  I2SCFG_CKPOL_STEADY_HIGH		|
								  I2SCFG_DATAFORMAT_32B;

    mp45dt02I2S2Config.i2spr     = (SPI_I2SPR_I2SDIV & MP45DT02_I2SDIV) |
                                  (SPI_I2SPR_ODD & (MP45DT02_I2SODD << I2SPR_I2SODD_SHIFT));

    i2sStart(&MP45DT02_I2S2_DRIVER, &mp45dt02I2S2Config);
    i2sStartExchange(&MP45DT02_I2S2_DRIVER);

    //*******************
    // I2S3 configuration
    //*******************
    memset(&mp45dt02I2s3Data, 0, sizeof(mp45dt02I2s3Data));
    mp45dt02I2s3Data.guard = MEMORY_GUARD;

    memset(&mp45dt02I2S3Config, 0, sizeof(mp45dt02I2S3Config));
    mp45dt02I2S3Config.tx_buffer = NULL;
    mp45dt02I2S3Config.rx_buffer = mp45dt02I2s3Data.buffer;
    mp45dt02I2S3Config.size      = MP45DT02_SAMPLE_SIZE_4B*2; // 2 ms of data
    mp45dt02I2S3Config.end_cb    = mp45dt02I2S3Cb; // Callback function called at half-fill (1 ms of data) and full-fill (1 ms of data).

    mp45dt02I2S3Config.i2scfgr   =	//I2SCFG_MODE_SLAVE_RECEIVE |
    								I2SCFG_MODE_MASTER_RECEIVE  |
    							  I2SCFG_STD_LSB_JUSTIFIED      |
                                  I2SCFG_CKPOL_STEADY_HIGH		|
								  I2SCFG_DATAFORMAT_32B;

    mp45dt02I2S3Config.i2spr     = (SPI_I2SPR_I2SDIV & MP45DT02_I2SDIV) |
                                  (SPI_I2SPR_ODD & (MP45DT02_I2SODD << I2SPR_I2SODD_SHIFT));

    i2sStart(&MP45DT02_I2S3_DRIVER, &mp45dt02I2S3Config);
    i2sStartExchange(&MP45DT02_I2S3_DRIVER);
}

void mp45dt02Shutdown(void)
{
    i2sStopExchange(&MP45DT02_I2S2_DRIVER);
    i2sStop(&MP45DT02_I2S2_DRIVER);

    i2sStopExchange(&MP45DT02_I2S3_DRIVER);
    i2sStop(&MP45DT02_I2S3_DRIVER);

    chThdTerminate(I2S2ProcessingThd);
    chSemReset(&I2S2ProcessingSem, 1);
    chThdWait(I2S2ProcessingThd);
    I2S2ProcessingThd = NULL;

    chThdTerminate(I2S3ProcessingThd);
    chSemReset(&I2S3ProcessingSem, 1);
    chThdWait(I2S3ProcessingThd);
    I2S3ProcessingThd = NULL;
}

